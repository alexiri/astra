{% extends "admin/import_export/import.html" %}

{% block extrastyle %}
  {{ block.super }}
  <style>
    /*
      import-export sets dark row backgrounds but doesn't always ensure
      foreground/link contrast matches Django admin themes. Force readable
      colors in the preview table.
    */
    /* table.import-preview {
      font-size: 14px;
      line-height: 1.35;
      width: 100%;
      table-layout: fixed;
    }

    table.import-preview th,
    table.import-preview td {
      overflow-wrap: anywhere;
      word-break: break-word;
      white-space: pre-wrap;
      vertical-align: top;
      color: var(--body-fg);
    }

    table.import-preview a,
    table.import-preview a:visited {
      color: var(--link-fg);
    }

    html[data-theme="dark"] table.import-preview tr.skip,
    html[data-theme="dark"] table.import-preview tr.new,
    html[data-theme="dark"] table.import-preview tr.update,
    html[data-theme="dark"] table.import-preview tr.delete {
      color: var(--body-fg);
    }

    html[data-theme="dark"] table.import-preview td ins {
      background-color: #183a18 !important;
      color: var(--body-fg) !important;
    }

    html[data-theme="dark"] table.import-preview td del {
      background-color: #3a1818 !important;
      color: var(--body-fg) !important;
    }

    table.import-preview {
      display: block;
      overflow-x: auto;
    } */

    table.import-preview tr.skip {
        background-color: lightgray;
    }
    table.import-preview tr.new {
        background-color: lightblue;
    }
    table.import-preview td ins {
        background-color: initial !important;
    }
  </style>
{% endblock %}

{% block extrahead %}
  <script>
    // Jazzmin's scripts assume a global `django` object (typically present on
    // stock Django admin pages). The import-export pages don't always provide
    // it, which can crash initialization and prevent subsequent JS from running.
    window.django = window.django || {};
    if (!window.django.jQuery && window.jQuery) {
      window.django.jQuery = window.jQuery;
    }
  </script>
  <script type="text/javascript" src="{% url 'admin:jsi18n' %}"></script>
  {% if confirm_form %}
    {{ confirm_form.media }}
  {% else %}
    {{ form.media }}
  {% endif %}
  {{ block.super }}
  <script>
    (function () {
      function norm(value) {
        return (value || "").toString().trim().toLowerCase().replace(/[^a-z0-9]/g, "");
      }

      function chooseDelimiter(line) {
        const candidates = [",", ";", "\t", "|"];
        let best = ",";
        let bestCount = -1;
        for (const d of candidates) {
          const count = (line.split(d).length - 1);
          if (count > bestCount) {
            bestCount = count;
            best = d;
          }
        }
        return best;
      }

      function parseCsvRow(line, delimiter) {
        const out = [];
        let cur = "";
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
          const ch = line[i];
          if (inQuotes) {
            if (ch === '"') {
              if (line[i + 1] === '"') {
                cur += '"';
                i++;
              } else {
                inQuotes = false;
              }
            } else {
              cur += ch;
            }
          } else {
            if (ch === '"') {
              inQuotes = true;
            } else if (ch === delimiter) {
              out.push(cur.trim());
              cur = "";
            } else {
              cur += ch;
            }
          }
        }
        out.push(cur.trim());
        return out.filter(Boolean);
      }

      function pickHeader(headers, preferredNorms) {
        const byNorm = new Map();
        for (const h of headers) {
          byNorm.set(norm(h), h);
        }
        for (const token of preferredNorms) {
          const found = byNorm.get(token);
          if (found) {
            return found;
          }
        }
        return "";
      }

      function setSelectOptions(selectEl, headers) {
        while (selectEl.options.length) {
          selectEl.remove(0);
        }
        selectEl.add(new Option("Auto-detect", ""));
        for (const h of headers) {
          selectEl.add(new Option(h, h));
        }
      }

      function initWhenReady() {
        const membershipTypeSelect = document.getElementById("id_membership_type");
        if (!membershipTypeSelect) {
          return false;
        }

        function currentMembershipTypeValue() {
          if (membershipTypeSelect && membershipTypeSelect.value) {
            return membershipTypeSelect.value;
          }

          // Select2 can temporarily leave the underlying <select> with an empty
          // value while it initializes. Fall back to the rendered selection.
          const rendered = document.getElementById("select2-id_membership_type-container");
          const renderedNorm = rendered ? norm(rendered.textContent) : "";
          if (renderedNorm.includes("mirror")) {
            return "mirror";
          }
          if (renderedNorm.includes("individual")) {
            return "individual";
          }
          return "";
        }

        function fieldRowForId(fieldId) {
          const el = document.getElementById(fieldId);
          if (!el) {
            return null;
          }

          // django-import-export's import template uses Django admin-ish markup,
          // but not always the exact same wrappers. We want to hide/show the
          // whole row (label + widget + help), not just the <select> wrapper.
          const byClosest =
            (el.closest && (el.closest(".form-row") || el.closest(".form-group"))) ||
            null;
          if (byClosest) {
            return byClosest;
          }

          const label = document.querySelector("label[for='" + fieldId + "']");
          if (label) {
            const labelRow =
              (label.closest && (label.closest(".form-row") || label.closest(".form-group"))) ||
              null;
            if (labelRow) {
              return labelRow;
            }
            return label.parentElement;
          }

          return el.parentElement;
        }

        function toggleQuestionFields() {
          if (!membershipTypeSelect) {
            return;
          }

          const isMirror = currentMembershipTypeValue() === "mirror";

          const contributionsRow = fieldRowForId("id_q_contributions_column");
          const domainRow = fieldRowForId("id_q_domain_column");
          const pullRequestRow = fieldRowForId("id_q_pull_request_column");
          const additionalInfoRow = fieldRowForId("id_q_additional_info_column");

          if (contributionsRow) {
            contributionsRow.style.display = isMirror ? "none" : "";
          }
          if (domainRow) {
            domainRow.style.display = isMirror ? "" : "none";
          }
          if (pullRequestRow) {
            pullRequestRow.style.display = isMirror ? "" : "none";
          }
          if (additionalInfoRow) {
            additionalInfoRow.style.display = isMirror ? "" : "none";
          }
        }

        function questionFieldVisibilityIsConsistent() {
          const isMirror = currentMembershipTypeValue() === "mirror";
          const contributionsRow = fieldRowForId("id_q_contributions_column");
          const domainRow = fieldRowForId("id_q_domain_column");
          const pullRequestRow = fieldRowForId("id_q_pull_request_column");
          const additionalInfoRow = fieldRowForId("id_q_additional_info_column");

          // If fields aren't present on this page, don't block.
          if (!contributionsRow && !domainRow && !pullRequestRow && !additionalInfoRow) {
            return true;
          }

          if (isMirror) {
            const mirrorRows = [domainRow, pullRequestRow, additionalInfoRow].filter(Boolean);
            if (!mirrorRows.length) {
              return true;
            }
            return mirrorRows.every((r) => r.style.display !== "none");
          }

          if (contributionsRow) {
            return contributionsRow.style.display !== "none";
          }
          return true;
        }

        const fields = {
          email: document.getElementById("id_email_column"),
          name: document.getElementById("id_name_column"),
          active: document.getElementById("id_active_member_column"),
          start: document.getElementById("id_membership_start_date_column"),
          notes: document.getElementById("id_committee_notes_column"),
          type: document.getElementById("id_membership_type_column"),
        };

        const headerList = document.getElementById("csv-header-preview");
        const headerListItems = document.getElementById("csv-header-preview-items");

        function applyHeaders(headers) {
          const selects = Array.from(document.querySelectorAll("select[id$='_column']"));
          for (const sel of selects) {
            setSelectOptions(sel, headers);
          }

          if (fields.email && !fields.email.value) {
            fields.email.value = pickHeader(headers, ["email", "emailaddress", "mail"]);
          }
          if (fields.name && !fields.name.value) {
            fields.name.value = pickHeader(headers, ["name", "fullname", "fullname", "displayname"]);
          }
          if (fields.active && !fields.active.value) {
            fields.active.value = pickHeader(headers, ["activemember", "active", "status", "memberstatus"]);
          }
          if (fields.start && !fields.start.value) {
            fields.start.value = pickHeader(headers, ["membershipstartdate", "startdate", "memberstartdate"]);
          }
          if (fields.notes && !fields.notes.value) {
            fields.notes.value = pickHeader(headers, ["committeenotes", "notes", "committee"]);
          }
          if (fields.type && !fields.type.value) {
            fields.type.value = pickHeader(headers, ["membershiptype", "type", "level"]);
          }

          for (const sel of selects) {
            if (sel.value) {
              continue;
            }
            const preferred = (sel.dataset && sel.dataset.preferredNorms) ? sel.dataset.preferredNorms : "";
            const preferredNorms = preferred.split("|").map(norm).filter(Boolean);
            if (preferredNorms.length) {
              sel.value = pickHeader(headers, preferredNorms);
            }
          }

          if (headerList && headerListItems) {
            headerListItems.textContent = headers.join(", ");
            headerList.style.display = headers.length ? "block" : "none";
          }
        }

        const fileInput = document.getElementById("id_import_file");
        if (fileInput) {
          fileInput.addEventListener("change", function () {
            const file = fileInput.files && fileInput.files[0];
            if (!file) {
              return;
            }

            const reader = new FileReader();
            reader.onload = function () {
              const text = (reader.result || "").toString();
              const lines = text.split(/\r\n|\n|\r/).filter(Boolean);
              if (!lines.length) {
                return;
              }
              const firstLine = lines[0].replace(/^\uFEFF/, "");
              const delimiter = chooseDelimiter(firstLine);
              const headers = parseCsvRow(firstLine, delimiter);
              if (headers.length) {
                applyHeaders(headers);
              }
            };
            reader.readAsText(file);
          });
        }

        membershipTypeSelect.addEventListener("change", toggleQuestionFields);

        // If Select2 is present, it emits events via jQuery rather than the DOM.
        if (window.jQuery) {
          try {
            window.jQuery(membershipTypeSelect).on("change select2:select select2:clear", toggleQuestionFields);
          } catch (e) {
            // If jQuery is present but can't bind for any reason, ignore.
          }
        }

        toggleQuestionFields();

        // Also re-run once Select2 has had a chance to initialize the original
        // <select> value from the rendered selection.
        setTimeout(toggleQuestionFields, 0);
        setTimeout(toggleQuestionFields, 250);

        // Select2 initialization timing is inconsistent across admin themes.
        // Keep re-applying the toggle briefly until the UI matches the selected
        // membership type.
        let toggleAttempts = 0;
        const toggleTimer = setInterval(function () {
          toggleAttempts += 1;
          toggleQuestionFields();

          if (questionFieldVisibilityIsConsistent() || toggleAttempts >= 30) {
            clearInterval(toggleTimer);
          }
        }, 100);

        return true;
      }

      function boot() {
        // If this script executes after DOMContentLoaded, we still need to
        // initialize. Retry briefly until the form fields exist.
        let attempts = 0;
        const timer = setInterval(function () {
          attempts += 1;
          if (initWhenReady() || attempts >= 50) {
            clearInterval(timer);
          }
        }, 50);
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", boot);
      } else {
        boot();
      }
    })();
  </script>
{% endblock %}

{% block import_form_additional_info %}
  {% include "admin/core/_membership_csv_import_additional_info.html" %}
{% endblock %}

{% block content %}
  {% if not confirm_form %}
    {# Jazzmin's import-export template doesn't render `import_form_additional_info`. #}
    {% include "admin/core/_membership_csv_import_additional_info.html" %}
  {% endif %}

  {% if unmatched_download_url %}
    <div class="messagelist">
      <ul class="messagelist">
        <li class="warning">Unmatched users export: <a href="{{ unmatched_download_url }}">download CSV</a></li>
      </ul>
    </div>
  {% endif %}

  {{ block.super }}
{% endblock %}
